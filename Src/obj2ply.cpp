#include "obj2ply.h"
#include "plyhead.h"
#include "ultitool.h"
#include "PCA/PCA.h"

#include <vcg/space/index/kdtree/kdtree.h>
#include <vcg/complex/algorithms/point_sampling.h>

#include <windows.h> 
#include <fstream>
#include <iostream>
#include <io.h>

using namespace std;

bool obj2ply(
	const string &inputObjFolder, 
	const string &outputPlyFolder,
	const unsigned int number_sample,
	const unsigned int noise_loc_dis, 
	const unsigned int noise_norm_ang)
{
	char _folderName[1024];
	if (number_sample > 1000 && (number_sample % 1000) == 0)
		sprintf(_folderName, "%dK_%02dU_%02dD", number_sample / 1000, noise_loc_dis, noise_norm_ang);
	else
		sprintf(_folderName, "%d_%02dU_%02dD", number_sample / 1000, noise_loc_dis, noise_norm_ang);

	const string folderName = _folderName;
	const string outFolder = outputPlyFolder + "/" + folderName;
	const string outReadMe = outputPlyFolder + "/" + folderName + "/ReadMe.md";
	cout
		<< endl
		<< "============================================\n"
		<< "[ -----           Obj2Ply            ----- ]\n"
		<< "[>] " << inputObjFolder << "\n"
		<< "[<] " << outFolder      << "\n"
		<< "[<] " << outReadMe      << "\n"
		<< "============================================\n"
		<< endl;
    CreateDirectoryA(outFolder.c_str(), NULL);

	ofstream fReadMeOut(outReadMe, ios::out);
	if (!fReadMeOut.is_open())
		return false;
	fReadMeOut
		<< folderName
		<< " : <NumberSample_NoiseLocDis_NoiseNormAng> \n"
		<< "Generated by WeiQM                         \n"
		<< "-------------------------------------------\n"
		<< endl;
	
	
	const string szPath = inputObjFolder + "/*.obj";
	intptr_t hFile = 0;
	struct _finddata_t fileinfo;
	if ((hFile = _findfirst(szPath.c_str(), &fileinfo)) != -1)
	{
		do
		{
			if ((fileinfo.attrib & _A_ARCH))
			{
				const string FileName   = fileinfo.name;
				const string BaseName   = FileName.substr(0, FileName.rfind('.'));
				const string inObjFile  = inputObjFolder + "/" + FileName;
				const string outPlyFile = outFolder + "/" + BaseName + ".ply";
				//----
				cout << FileName << endl;
				fReadMeOut << inObjFile << "\t --> \t" << outPlyFile << endl;
				//----
				MeshDocument MeshDoc;
				if (!MeshDoc.loadMesh(inObjFile.c_str())) {
					cout << "[Error] : Failed to Open Obj File." << endl;
					fReadMeOut << "[Error] : Failed to Open Obj File." << endl;
					fReadMeOut.close();
					return false;
				}
				CMeshO &mesh = MeshDoc.mesh->cm;

				double squre = 0.0;
				for (CMeshO::FaceIterator fi = mesh.face.begin(); fi != mesh.face.end(); ++fi)
					squre += tri_area(fi->cP(0), fi->cP(1), fi->cP(2));

				double r = number_sample*1.0 / squre;
				vector<vcg::Point3f> vert;
				vector<vcg::Point3f> norm;
				vector<vcg::Color4b> color;
#if 0
				for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi) {
					vert.push_back(vi->cP());
					norm.push_back(vi->cN());
					color.push_back(vi->cC());
				}
				r = (SampleN - mesh.vn) / squre;
#endif
				for (CMeshO::FaceIterator fi = mesh.face.begin(); fi != mesh.face.end(); ++fi) {
					const CVertexO *c0 = fi->cV(0);
					const CVertexO *c1 = fi->cV(1);
					const CVertexO *c2 = fi->cV(2);
					vcg::Point3f n = tri_norm(c0->cP(), c1->cP(), c2->cP());
					int k = tri_area(c0->cP(), c1->cP(), c2->cP()) * r + 0.5;
					for (int i = 0; i < k; ++i) {
						vcg::Point3f p;
						vcg::Color4b c;
						tri_random(p, c, c0->cP(), c1->cP(), c2->cP(), c0->cC(), c1->cC(), c2->cC());
						vert.push_back(p);
						norm.push_back(n);
						color.push_back(c);
					}
				}
				cout << "  >> # Number of Points :" << vert.size() << endl;
				fReadMeOut << "  >> # Number of Points : " << vert.size() << endl;
				if (savePly(outPlyFile.c_str(), vert, norm, color) != vert.size()) {
					fReadMeOut << "[Error] : Failed to Save Ply File." << endl;
					fReadMeOut.close();
					return false;
				}

				if (noise_loc_dis != 0 || noise_norm_ang != 0) {
					if (!addPlyNoise(outPlyFile, noise_loc_dis, noise_norm_ang)) {
						cout << "[Error] : Failed to Add Noise." << endl;
						fReadMeOut << "[Error] : Failed to Add Noise." << endl;
						fReadMeOut.close();
						return false;
					}
				}
			}
		} while (_findnext(hFile, &fileinfo) == 0);
		_findclose(hFile);
	}
	fReadMeOut.close();
	return true;
}

int savePly(
	const string &plyPath,
	const vector<vcg::Point3f> &V,
	const vector<vcg::Point3f> &N,
	const vector<vcg::Color4b> &C)
{
	ofstream fout(plyPath, ios::out);
	if (fout.is_open()) {
		fout.precision(6);

		bool hasNorm = !N.empty();
		bool hasColor = !C.empty();

		if ((hasNorm  && V.size() != N.size()) ||
			(hasColor && V.size() != C.size()))
			return -2;

		int Count = V.size();
		char plyHead[1024];
		if (hasNorm && hasColor) sprintf(plyHead, PlyHeadPNC, Count);
		else if (hasNorm)       sprintf(plyHead, PlyHeadPN, Count);
		else if (hasColor)       sprintf(plyHead, PlyHeadPC, Count);
		else                     sprintf(plyHead, PlyHeadP, Count);
		fout << plyHead;

		for (int i = 0; i < Count; ++i) {
			fout << V[i].X() << " " << V[i].Y() << " " << V[i].Z();
			if (hasNorm)
				fout << " " << N[i].X() << " " << N[i].Y() << " " << N[i].Z();
			if (hasColor)
				fout << " " << (unsigned int)C[i].V(0) << " " << (unsigned int)C[i].V(1) << " " << (unsigned int)C[i].V(2);
			fout << endl;
		}
		fout.close();
		return Count;
	}
	return -1;
}


double MeshSizeAlongN(CMeshO &mesh, const vcg::Point3f n)
{
	double minDis = DBL_MAX;
	double maxDis = -DBL_MAX;
	vcg::Point3f normalN = n;
	normalN.Normalize();
	for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi)
	{
		if ((*vi).IsD())
			continue;
		double proLoc = (*vi).cP()*normalN;
		if (proLoc > maxDis) maxDis = proLoc;
		if (proLoc < minDis) minDis = proLoc;
	}
	return abs(maxDis - minDis);
}
bool PCADimensions(
	CMeshO &mesh,
	vector<vcg::Point3f> &PDirections,
	vcg::Point3f &PSize)
{
	//----[[
	// 1. Call PCA
	const int N = mesh.vn;
	int row = 3, col = N;
	double *data = new double[3 * N];
	int Count = 0;
	for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi)
	{
		if ((*vi).IsD())
			continue;
		data[Count] = (*vi).cP().X();
		data[N + Count] = (*vi).cP().Y();
		data[2 * N + Count] = (*vi).cP().Z();
		++Count;
	}
	assert(Count == N);
	double PC[9], V[3];//V[3] useless
	int ret = PCA(data, row, col, PC, V);
	delete[] data;
	if (ret == -1)
		return false;

	// 2. Normalize And Assign
	vcg::Point3f NX = vcg::Point3f(PC[0], PC[3], PC[6]);
	vcg::Point3f NY = vcg::Point3f(PC[1], PC[4], PC[7]);
	vcg::Point3f NZ = vcg::Point3f(PC[2], PC[5], PC[8]);
	NX.Normalize();
	NY.Normalize();
	NZ.Normalize();

	PSize.X() = MeshSizeAlongN(mesh, NX);
	PSize.Y() = MeshSizeAlongN(mesh, NY);
	PSize.Z() = MeshSizeAlongN(mesh, NZ);

	PDirections.clear();
	PDirections.push_back(NX);
	PDirections.push_back(NY);
	PDirections.push_back(NZ);

	return true;
}
double Roughness(CMeshO &mesh)
{
    //----[[

	// 1. Build KD-Tree
	vcg::VertexConstDataWrapper<CMeshO> ww(mesh);
	vcg::KdTree<float> KDTree(ww);
	vcg::KdTree<float>::PriorityQueue queue;

	// 2. Fit at Each Point
	// Key Parameter
	// refa = a*miu + b*std	
	const int knn = 30;
	const int a = 1.0;
	const int b = 3.0;
	const int N = mesh.vn;

	int Count = 0;
	double R = 0.0;
	for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi)
	{
		if ((*vi).IsD())
			continue;

		// 1) Query KNN
		KDTree.doQueryK((*vi).cP(), knn, queue);
		int neighbours = queue.getNofElements();

		// 2) Fit KNN
		std::vector<vcg::Point3f> Pts;
		vcg::Plane3f ple;
		for (int i = 0; i < neighbours; i++) {
			int neightId = queue.getIndex(i);
			Pts.push_back(mesh.vert[neightId].cP());
		}
		vcg::FitPlaneToPointSet(Pts, ple);

		// 3) Cal u and v
		double miu = 0.0;
		double sigma = 0.0;
		for (int i = 0; i < neighbours; ++i) {
			float d = vcg::SignedDistancePlanePoint(ple, Pts[i]);
			miu += abs(d);
			sigma += d*d;
		}
		R += a * (miu / neighbours) + b * sqrt(sigma / neighbours);
		++Count;
	}
	assert(Count == N);
	double roughness = R / Count;

	//----]]
	return roughness;
}


bool addPlyNoise(
	const string &plyPath,
	const unsigned int noise_loc_dis,
	const unsigned int noise_norm_ang)
{
	if (noise_loc_dis == 0 && noise_norm_ang == 0)
		return true;

	MeshDocument MeshDoc;
	if (!MeshDoc.loadMesh(plyPath.c_str()))
		return false;
	CMeshO &mesh = MeshDoc.mesh->cm;

	vcg::math::MarsenneTwisterRNG rnd;
	default_random_engine randomEngine;

	if (noise_loc_dis != 0) {
		vcg::Point3f PSize;
		vector<vcg::Point3f> PDirection;
		PCADimensions(mesh, PDirection, PSize);
		double PCASize = PSize.V(2)*0.01;
		double nDis = PCASize*noise_loc_dis;
		for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi)
		{
			if ((*vi).IsD())
				continue;
			RandomTranslate(vi->P(), nDis, rnd, randomEngine);
		}
	}
	if (noise_norm_ang != 0) {
		double nAng = noise_norm_ang;
		for (CMeshO::VertexIterator vi = mesh.vert.begin(); vi != mesh.vert.end(); ++vi)
		{
			if ((*vi).IsD())
				continue;
			RandomRotate(vi->N(), nAng, rnd, randomEngine);
		}
	}

	return MeshDoc.saveMesh(plyPath.c_str(), false);
}